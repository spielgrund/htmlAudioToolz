<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Batch WAV Converter with ZIP & Progress</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<style>
  body { font-family: Arial, sans-serif; margin: 20px; }
  #progressContainer { margin-top: 10px; display: none; }
  #progressBar { width: 100%; background: #eee; border-radius: 8px; overflow: hidden; }
  #progressFill { height: 20px; width: 0%; background: #4caf50; transition: width 0.2s; }
  label { font-weight: bold; }
</style>
</head>
<body>
<h1>Batch WAV Sample Rate Converter (ZIP)</h1>

<input type="file" id="wavFiles" accept=".wav" multiple><br><br>

<label for="sampleRate">Target Sample Rate (kHz): </label>
<input type="number" id="sampleRate" value="44.1" step="0.1"><br><br>

<label for="bitDepth">Bit Depth: </label>
<select id="bitDepth">
  <option value="8">8-bit PCM</option>
  <option value="16" selected>16-bit PCM</option>
  <option value="24">24-bit PCM</option>
  <option value="32">32-bit Float</option>
</select>
<br><br>

<label for="postfix">Filename Postfix: </label>
<input type="text" id="postfix" placeholder="e.g. _converted"><br><br>

<label for="mono">Convert to Mono: </label>
<input type="checkbox" id="mono"><br><br>

<button id="convertBtn">Convert and Download ZIP</button>
<button id="cancelBtn" disabled>Cancel</button><br><br>

<div id="progressContainer">
  <div id="progressBar"><div id="progressFill"></div></div>
  <p id="progressText"></p>
</div>

<div id="status"></div>

<script>
const fileInput = document.getElementById('wavFiles');
const sampleRateInput = document.getElementById('sampleRate');
const postfixInput = document.getElementById('postfix');
const bitDepthSelect = document.getElementById('bitDepth');
const monoCheckbox = document.getElementById('mono');
const convertBtn = document.getElementById('convertBtn');
const cancelBtn = document.getElementById('cancelBtn');
const statusDiv = document.getElementById('status');
const progressContainer = document.getElementById('progressContainer');
const progressFill = document.getElementById('progressFill');
const progressText = document.getElementById('progressText');

let cancelRequested = false;

convertBtn.addEventListener('click', async () => {
    const files = fileInput.files;
    if (!files.length) {
        alert("Please select WAV files.");
        return;
    }

    const targetRate = parseFloat(sampleRateInput.value) * 1000;
    if (isNaN(targetRate) || targetRate <= 0) {
        alert("Please enter a valid target sample rate in kHz.");
        return;
    }

    const bitDepth = parseInt(bitDepthSelect.value);
    const postfix = postfixInput.value.trim();
    const convertMono = monoCheckbox.checked;

    cancelRequested = false;
    cancelBtn.disabled = false;
    progressContainer.style.display = "block";
    progressFill.style.width = "0%";
    progressText.textContent = `0 / ${files.length} files processed`;

    const zip = new JSZip();

    for (let i = 0; i < files.length; i++) {
        if (cancelRequested) {
            statusDiv.textContent = "Conversion cancelled.";
            cancelBtn.disabled = true;
            return;
        }

        const file = files[i];
        const arrayBuffer = await file.arrayBuffer();
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);

        const numChannels = convertMono ? 1 : audioBuffer.numberOfChannels;

        const offlineCtx = new OfflineAudioContext(
            numChannels,
            Math.ceil(audioBuffer.duration * targetRate),
            targetRate
        );

        const source = offlineCtx.createBufferSource();
        let bufferToUse = audioBuffer;

        if (convertMono && audioBuffer.numberOfChannels > 1) {
            // mix down to mono
            const monoData = new Float32Array(audioBuffer.length);
            for (let c = 0; c < audioBuffer.numberOfChannels; c++) {
                const channelData = audioBuffer.getChannelData(c);
                for (let j = 0; j < audioBuffer.length; j++) {
                    monoData[j] += channelData[j] / audioBuffer.numberOfChannels;
                }
            }
            const newBuffer = offlineCtx.createBuffer(1, audioBuffer.length, audioBuffer.sampleRate);
            newBuffer.copyToChannel(monoData, 0);
            bufferToUse = newBuffer;
        }

        source.buffer = bufferToUse;
        source.connect(offlineCtx.destination);
        source.start(0);

        const renderedBuffer = await offlineCtx.startRendering();
        const wavBlob = bufferToWav(renderedBuffer, bitDepth);

        const baseName = file.name.replace(/\.wav$/i, "");
        const newName = `${baseName}${postfix || ""}.wav`;
        zip.file(newName, wavBlob);

        // Update progress
        const percent = Math.round(((i + 1) / files.length) * 100);
        progressFill.style.width = percent + "%";
        progressText.textContent = `${i + 1} / ${files.length} files processed`;
    }

    statusDiv.textContent = "Generating ZIP...";
    cancelBtn.disabled = true;

    const zipBlob = await zip.generateAsync({ type: "blob" });
    const zipUrl = URL.createObjectURL(zipBlob);

    const link = document.createElement('a');
    link.href = zipUrl;
    link.download = `converted_${targetRate/1000}kHz_${bitDepth}bit.zip`;
    link.click();

    statusDiv.textContent = "Done! Your ZIP is ready for download.";
});

cancelBtn.addEventListener('click', () => {
    cancelRequested = true;
    cancelBtn.disabled = true;
});

// WAV encoding function with bit depth support
function bufferToWav(buffer, bitDepth) {
    const numOfChan = buffer.numberOfChannels;
    const bytesPerSample = bitDepth === 8 ? 1 : bitDepth === 24 ? 3 : bitDepth === 32 ? 4 : 2;
    const length = buffer.length * numOfChan * bytesPerSample + 44;
    const bufferArray = new ArrayBuffer(length);
    const view = new DataView(bufferArray);

    let offset = 0;
    function writeString(s) { for (let i = 0; i < s.length; i++) view.setUint8(offset++, s.charCodeAt(i)); }

    writeString('RIFF');
    view.setUint32(offset, length - 8, true); offset += 4;
    writeString('WAVE');
    writeString('fmt ');
    view.setUint32(offset, 16, true); offset += 4;
    view.setUint16(offset, bitDepth === 32 ? 3 : 1, true); offset += 2;
    view.setUint16(offset, numOfChan, true); offset += 2;
    view.setUint32(offset, buffer.sampleRate, true); offset += 4;
    view.setUint32(offset, buffer.sampleRate * numOfChan * bytesPerSample, true); offset += 4;
    view.setUint16(offset, numOfChan * bytesPerSample, true); offset += 2;
    view.setUint16(offset, bitDepth, true); offset += 2;
    writeString('data');
    view.setUint32(offset, length - offset - 4, true); offset += 4;

    const channels = [];
    for (let i = 0; i < numOfChan; i++) channels.push(buffer.getChannelData(i));

    let pos = offset;
    for (let i = 0; i < buffer.length; i++) {
        for (let ch = 0; ch < numOfChan; ch++) {
            let sample = Math.max(-1, Math.min(1, channels[ch][i]));

            if (bitDepth === 8) {
                const val = Math.round((sample + 1) * 127.5);
                view.setUint8(pos++, val);
            } else if (bitDepth === 16) {
                view.setInt16(pos, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                pos += 2;
            } else if (bitDepth === 24) {
                let s = sample < 0 ? sample * 0x800000 : sample * 0x7FFFFF;
                s = Math.max(-8388608, Math.min(8388607, s));
                view.setUint8(pos++, s & 0xFF);
                view.setUint8(pos++, (s >> 8) & 0xFF);
                view.setUint8(pos++, (s >> 16) & 0xFF);
            } else if (bitDepth === 32) {
                view.setFloat32(pos, sample, true);
                pos += 4;
            }
        }
    }

    return new Blob([view], { type: "audio/wav" });
}
</script>
</body>
</html>
